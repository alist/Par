
Files

Def.def - marcros that bootstrap the Par parser
Def.par - what the Par looks like defined by itself




Par extends PCRE regular expressions with a symbolic toked stream.

For example, the grammar

    def (hello world)
    hello ('hello')
    world ('world')

    "hello world" // will convert this string into the following token stream

    0, 1: def :
    1, 2:  hello : hello
    2, 2:  world : world

Par supports alternation '|' and repetition '+','*','?'
and behaves as expected. So, changing def to:

    def (hello | world)+
    hello ('hello')
    world ('world')

    "hello world" // changes the output stream to two defs:

    0, 1: def :
    1, 2:  hello : hello
    2, 1: def :
    3, 2:  world : world

Par uses PCRE to match everything between the ' ' quotes.
So, the the regex patterns behave as expected, including:

    '^' to match at the beginning
    '?' as an optional and
    '$' to match at the end of the line

So, the grammar:

    def (hello | world)+
    hello ('he?ll?o')
    world ('wo?rld$')

    "hlo yo wrld" // will match "hlo", ignore "yo" and match "wrld"

    0, 1: def :
    1, 2:  hello : hlo
    2, 1: def :
    3, 2:  world : wrld

When Par matches a pattern it advances the document pointer past the match
to the next non-whitespace character. So, the following grammar
with 'world' and 'hello' reversed:

    def (world | hello)+
    hello ('hello')
    world ('world')

    "hello world" // will match "world" first, advance the doc pointer and miss "hello"

    0, 1: def :
    1, 2:  world : world

To not advance the pointer, use a preceeding 'n' before the single quote, like so

    def (world | hello)+
    hello (n'hello')
    world (n'world')

    "hello world" // which will yield independant def results

    0, 1: def :
    1, 2:  world : world
    2, 1: def :
    3, 2:  hello : hello

Above, 'hello' and 'world' are NOT anchored. Could anchor to
the beginning with '^' and '$', like so:

    def (hello world)
    hello (n'^hello')
    world (n'world$')

    "hello big beautifil world" // which anchors to beginning and end

    0, 1: def :
    1, 2:  hello : hello
    2, 2:  world : world

To capture everything everthing between, use '~' infront of a name, like so:

    def (hello ~middle world)
    hello ('^hello')
    world ('^world')

    "hello big beautifil world" // will still result in

    0, 1: def :
    1, 2:  world : world
    2, 1: def :
    3, 2:  hello : hello

To make the match case independant, use a preceeding 'i'

    def (hello world)+
    hello (i'hello')
    world (i'world')

    "Hello WORLD" // which will match the mixed case string
    0, 1: def :
    1, 2:  hello : Hello
    2, 2:  world : WORLD

Par doesnt require a surrounding parens'()'. But, an inner parens:

    def (hello world)+
    hello ('he(ll)?o') // here
    world ('world')

    "hello world" //  will return a confusing result:

    0, 1: def :
    1, 2:  hello : ll
    2, 2:  world : world

So, add surrounding parens

    def (hello world)+
    hello ('(he(ll)?o)') // here
    world ('world')

    "hello world" //  to resolve what value is returned

    0, 1: def :
    1, 2:  hello : hello
    2, 2:  world : world

Par also matches string literals between double quotes "..."
Which comes in handy for parsing characters that have special Regex meanings
such as ()[]{}!$^*? .

    def (hello world paren? emoji?)+
    hello ('hello')
    world ('world')
    paren ("(" aside ")")
    aside (i'[a-z ]*')
    emoji('^üòä|üòÉ|üòè|üòà')

    "hello world (yo) üòä" // resulting in the following stream

    0, 1: def :
    1, 2:  hello : hello
    2, 2:  world : world
    3, 2:  paren :
    4, 3:   aside : yo
    5, 2:  emoji : üòä

Notice that 'paren(...)' combined literals and symbols. If the values are not needed,
we could go crazy and combine everything together in a compound statement like, so:

    woohoo ('hello' 'world' ("(" i'[a-z ]*' ")")? '^üòä|üòÉ|üòè|üòà')+

    "hello beautiful world (yo) üòä" // resulting in a single token

     0, 1: woohoo : üòä

RECURSION

Right recursion is allowed; as long as there is preceeding pattern
that matches one more times

    def (hello def? ~wild world)+
    hello (i'^hello'|i'(good (morning|afternoon|evening))')
    world (i'^world'|i'^planet'|i'^earth')

    "Hello good morning big beautiful planet earth"

    0, 1: def :
    1, 2:  hello : Hello
    2, 2:  def :
    3, 3:   hello : good morning
    4, 3:   ~wild : big beautiful
    5, 3:   world : planet
    6, 2:  world : earth

Left recursion will exit the app, so:

    def (def? hello world)  // or
    def (hello* def? world) // for

    "hello world " // will result in the following message

    *** def:parse exceeded maximum levels: 200 ***

ISLAND PARSING

The wave '~' (tilde) searches in parallel. For Example:
{
    def (aloha ~ hello ~ world ~ close)
    aloha (i'^aloha')
    hello (i'^hello'|i'^(good (morning|afternoon|evening))')
    world (i'^world'|i'^planet'|i'^earth')
    close (i'^yours truly')
    
    // Given the following input document
    
    "Yo! Good morning big beautiful planet earth - Aloha from yours truly."
    
    // produced the following token stream (#,level: name, value)
    
    0, 2:  ~     : Yo!
    1, 2:  hello : Good morning
    2, 2:  ~     : big beautiful
    3, 2:  world : planet
    4, 2:  world : earth
    5, 2:  ~     : -
    6, 2:  aloha : Aloha
    7, 2:  ~     : from
    8, 2:  close : yours truly
    9, 2:  ~     : .
}
The '~' tokens are the unmatched portions from the document -- the water between
the islands.

Using the '~' can be slow if there are many words between matches, as Par will
advance word by word, and try all the the patterns until a match is found.



------------------------------------

sent (words)+
words (~aaaa hello ~bbbb world ~cccc punct)
punct ('[.!?]')
hello (i'^hello')
world (i'^world')
more  ('^beautiful'|'^big'|'^world')+

"yo hello big beautiful world. hello world yo."

0, 1: sent :
1, 2:  words :
2, 3:   ~aaaa : yo
3, 3:   hello : hello
4, 3:   ~bbbb : big beautiful
5, 3:   world : world
6, 3:   ? : .
7, 2:  words :
8, 3:   hello : hello
9, 3:   world : world
10, 3:   ~cccc : yo
11, 3:   ? : .

------------------------------------

def (hello ~ world ~ emoji)+
hello ('^hello')
world ('^world')
emoji('^üòä|üòÉ|üòè|üòà')

"hello üòä world"

0, 2:  hello : hello
1, 2:  emoji : üòä
2, 2:  world : world

