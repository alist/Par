
Files

Def.def     - marcros that define the Par parser
Def.par     - informal description of Par syntax
ParMacro.h  - convert macros to Par grammar, used only for bootstrap
ParDef.*    - bootstrap the Par parser from Def.def

Par.*       - main parsing of input document
ParPar.*    - convert *.def file into grammar
ParDoc.*    - manage an input document with shared buffer
ParTok.*    - Token stream
ParQuo.*    - match a literal string
ParRegx.*   - match a regex pattern

Tok.*       - token item produced by parse
TokTypes.h  - types shared by all token items
TokStack.*  - utility for calling code to manage hierachy

pcre*.*     - Perl-Compatible Regular Expressions

<name>.def  - definition file for a grammar
<name>.test - test source example for <name>.def

ParTest.cpp - run tests - also the first working example that uses Par to parse a file
ParTest.def - definition of macros to read and run Par tests
ParTest.test - set of test examples to run and verify

WALKTRHOUGH of syntax -------------------------------------------------

Par extends regular expressions with a symbolic token stream
that includes a: tokId, level, symbol, and optional value.

For example, the grammar

    yo (hello world)
    hello ('hello')
    world ('world')

    "hello world" // will convert this string into the following token stream

    0, 1: yo :
    1, 2:  hello : hello
    2, 2:  world : world

The top name can be anything, 'yo', 'oy', whatever you want

Par supports alternation '|' and quantifiers:
    '+ {1,} ' // 1 or more
    '* {0,} ' // 0 or more
    '? {0,1}' // zero or 1
    '  {2}  ' // exactly 2
    '  {2,3}' // 2 or 3
    '  {,3} ' // up to 3

So, changing def to:

    def (hello | world)+
    hello ('hello')
    world ('world')

    "hello world" // changes the output stream to two defs:

    0, 1: def :
    1, 2:  hello : hello
    2, 1: def :
    3, 2:  world : world

Par uses PCRE to match everything between the '...' quotes.
So, the regex patterns behave as expected, including:

    '^' to match at the beginning ('^first')
    '$' anchor to end of line ('last$')
    plus all of the standard quantifiers *+?{}

So, the grammar:

    def (hello | world)+
    hello ('he?ll?o')
    world ('wo?rld$')

    "hlo yo wrld" // will match "hlo", ignore "yo" and match "wrld"

    0, 1: def :
    1, 2:  hello : hlo
    2, 1: def :
    3, 2:  world : wrld

When Par matches a pattern it advances the document pointer past the match
to the next non-whitespace character. Thus, anchoring with '^' is crucial
For example, swapping the order of world and hello, without an anchor:


    def (world | hello)+ // will search for 'world' first
    hello ('hello')
    world ('world')

    "hello world" // skipping hello, resulting in only one match

    0, 1: def :
    1, 2:  world : world

To fix, anchor with '^'

    def (world | hello)+
    hello ('^hello')
    world ('^world')

    "hello world" // which will yield independant def results

    0, 1: def :
    1, 2:  hello : hello
    2, 1: def :
    3, 2:  world : world

There is also an option to (n' ') to not advance cursor.

    def (hello world)
    hello (n'^hello') // find hello at beginning without moving cursor
    world (n'world$')// find world at and without moving cursor

    "hello big beautiful world" // which ignores everytning in between

    0, 1: def :
    1, 2:  hello : hello
    2, 2:  world : world

To capture everything everthing between, use '~name' which looks ahead
to see if the following pattern matches. So:

    def (hello ~middle world)
    hello ('^hello')
    world ('^world')

    "hello big and beautiful world" // will result in

    0, 1: def :
    1, 2:  hello : hello
    2, 2:  ~middle : big beautiful
    3, 2:  world : world

Above, '~middle' didnt match subsequent definitions.
To add a subsearch, define a 'middle':
    
    def (hello ~middle world)
    hello ('^hello')
    world ('^world')
    middle ('big' | 'beautiful')+ // now middle does a subsearch
    
    0, 1: def :
    1, 2:  hello : hello
    2, 4:    ~middle : big
    3, 4:    ~middle : beautiful
    4, 2:  world : world

Another option is (i'...') to match independant of case:

    def (hello world)+
    hello (i'hello')
    world (i'world')

    "Hello WORLD" // which will match the mixed case string

    0, 1: def :
    1, 2:  hello : Hello
    2, 2:  world : WORLD

Par doesnt require a surrounding parens'(...)'.
But, is sometimes worthwhile of have an inner set of parens:

    def (hello world)+
    hello ('h(el)?lo') // here to match either hello or hlo
    world ('world')

    "hello world" //  will return a confusing result:

    0, 1: def :
    1, 2:  hello : el
    2, 2:  world : world

So, add surrounding parens

    def (hello world)+
    hello ('(he(ll)?o)') // here
    world ('world')

    "hello world" // to insure that the full input is returned

    0, 1: def :
    1, 2:  hello : hello
    2, 2:  world : world

Par also matches string literals between double quotes "..."
Which comes in handy for parsing special characters that may be less readable as a regex:
such as ()[]{}!$^*? .

    def (hello world paren? emoji?)+
    hello ('hello')
    world ('world')
    paren ("(" inside ")")
    inside (i'[a-z ]*')
    emoji('^üòä|üòÉ|üòè|üòà')

    "hello world (yo) üòä" // resulting in the following stream

    0, 1: def :
    1, 2:  hello : hello
    2, 2:  world : world
    3, 2:  paren :
    4, 3:   inside : yo
    5, 2:  emoji : üòä

Notice that 'paren(...)' combined literals and symbols. If the values are not needed,
we could go crazy and combine everything together in a compound statement like, so:

    woohoo ('hello' 'world' ("(" i'[a-z ]*' ")")? '^üòä|üòÉ|üòè|üòà')+

    "hello beautiful world (yo) üòä" // resulting in a single token

     0, 1: woohoo : üòä

RECURSION -------------------------------------------------

Right recursion is allowed; as long as there is preceeding pattern
that matches one more times

    def (hello def? world)+
    hello (i'^hello'|i'(good (morning|afternoon|evening))')
    world (i'^world'|i'^planet'|i'^earth')

    "Hello good morning planet earth"

    0, 1: def :
    1, 2:  hello : Hello
    2, 2:  def :
    3, 3:   hello : good morning
    4, 3:   world : planet
    5, 2:  world : earth

Left recursion will exit the app:

    def (def? hello world)  // or
    def (hello* def? world) // for

    "hello world" // will result in the following message

    *** def:parse exceeded maximum levels: 200 ***

ISLAND PARSING -------------------------------------------------

The wave '~' (tilde) searches in parallel. For Example:

    def (aloha ~ hello ~ world ~ close)
    aloha (i'^aloha')
    hello (i'^hello'|i'^(good (morning|afternoon|evening))')
    world (i'^world'|i'^planet'|i'^earth')
    close (i'^yours truly')
    
    // Given the following input document
    
    "Yo! Good morning big beautiful planet earth - Aloha from yours truly."
    
    // produced the following token stream (#,level: name, value)
    
    0, 2:  ~ : Yo!
    1, 2:  hello : Good morning
    2, 2:  ~ : big beautiful
    3, 2:  world : planet
    4, 2:  world : earth
    5, 2:  ~ : -
    6, 2:  aloha : Aloha
    7, 2:  ~ : from
    8, 2:  close : yours truly
    9, 2:  ~ : .

The '~' tokens are the unmatched portions from the document -- the water between
the islands. Par will advance word by word, and try all the the patterns until a
match is found.


GOTCHA - LookAhead between literal quotes -------------------------------

Literal quotes treat everthing that is not a white space as part of word,
which is fine for left to right matching like so:

    paren ("(" inside ")") // this matches
    inside (i'[a-z ]*')

    "yo" // will produce the input stream:

     1, 2:  inside : yo

whereas lookahead between quotes will fail

    paren ("(" ~inside ")") // this doesn't match
    
After matching the first "(" the lookahead ")" tries to match 'yo)'
here is a trace:
    
    ‚¶ô(yo)     ‚¶ô   1: paren
    ‚¶ôyo)      ‚¶ô   2:   0, 1: paren :
    // no tokens were produced

To fix, use a regex with initial anchor '^(' and unanchored ')'
    
    paren ('^\(' ~inside '\)') // producing the token stream
    
    0, 1: paren :
    1, 4:    ~inside : yo

