
Par extends PCRE regular expressions with a symbolic toked stream. For example:

    def (hello world)
    hello ('hello')
    world ('world')


will parse the following string

    "hello world"

to produce the following token stream

    0, 1: def :
    1, 2:  hello : hello
    2, 2:  world : world

Par supports alternation '|' and repetition '+','*','?'
and behaves as expected. So, changing def to:

    def (hello | world)+
    hello ('hello')
    world ('world')

    "hello world" // changes the output stream to two defs:

    0, 1: def :
    1, 2:  hello : hello
    2, 1: def :
    3, 2:  world : world

Par uses PCRE to match everything between the ' ' quotes.
So, the the regex patterns behave as expected, including:

    '^' to match at the beginning
    '?' as an optional and
    '$' to match at the end of the line

So, the following def

    def (hello | world)+
    hello ('^he?ll?o')
    world ('wo?rld$')

    "hlo yo wrld" // will match "hlo", ignore "yo" and match "wrld"

    0, 1: def :
    1, 2:  hello : hlo
    2, 1: def :
    3, 2:  world : wrld

One thing to keep in mind is that as Par matches a pattern it will
advance the document pointer to the next non-whitespace character.
So the following def with 'world' and 'hello' reversed:

    def (world | hello)+
    hello ('hello')
    world ('world')

    "hello world" // will match "world" first, advance the doc pointer and miss "hello"

    0, 1: def :
    1, 2:  world : world

To not advance the pointer, use a preceeding (n'...') like so

    def (world | hello)+
    hello (n'hello')
    world (n'world')

    "hello world" // which will yield independant def results

    0, 1: def :
    1, 2:  world : world
    2, 1: def :
    3, 2:  hello : hello

Which comes in handy for island parsers.
But, be careful, as it will only match once for the same document:

    "hello world hello hello" // will still result in

    0, 1: def :
    1, 2:  world : world
    2, 1: def :
    3, 2:  hello : hello

To make the match case independant, use a preceeding 'i'

    def (hello world)+
    hello (i'hello')
    world (i'world')

    "Hello WORLD" // which will match the mixed case string
    0, 1: def :
    1, 2:  hello : Hello
    2, 2:  world : WORLD

Par does not require a surrounding parens'()' to return the match result.
However, an inner parens

    def (hello world)+
    hello ('he(ll)?o')
    world ('world')

    "hello world" //  can result a confusing result:

    0, 1: def :
    1, 2:  hello : ll
    2, 2:  world : world

So, add surrounding parens

    def (hello world)+
    hello ('(he(ll)?o)')
    world ('world')

    "hello world" //  to resolve what value is returned

    0, 1: def :
    1, 2:  hello : hello
    2, 2:  world : world

Par also matches string literals between double quotes "..."
Which comes in handy for parsing characters that have special Regex meanings
such as ()[]{}!$^*? .


    def (hello world paren? emoji?)+
    hello ('hello')
    world ('world')
    paren ("(" aside ")")
    aside (i'[a-z ]*')
    emoji('^ğŸ˜Š|ğŸ˜ƒ|ğŸ˜|ğŸ˜ˆ')

    "hello world (yo) ğŸ˜Š" // resulting in the following stream

    0, 1: def :
    1, 2:  hello : hello
    2, 2:  world : world
    3, 2:  paren :
    4, 3:   aside : yo
    5, 2:  emoji : ğŸ˜Š

Notice that 'paren(...)' combined literals and symbols. If the values are not needed,
we could combine everything together in a compound statement like, so:

    woohoo ('hello' 'world' ("(" i'[a-z ]*' ")")? '^ğŸ˜Š|ğŸ˜ƒ|ğŸ˜|ğŸ˜ˆ')+

    "hello beautiful world (yo) ğŸ˜Š" // resulting in a single token

    0, 1: woohoo :





